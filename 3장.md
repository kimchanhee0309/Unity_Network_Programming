# 통신 프로그램을 만들자

<details>
<summary>3.1 소켓 프로그래밍을 시작하자</summary>
<div markdown="1">       

### 소켓이란?
* **소켓(socket)**
  * TCP와 UDP를 간단하게 다루기 위한 통신 API
  * `IP 주소` 와 `포트 번호`를 한 조로 통신 상대를 지정하고 통신함
  * 통신 상대로는 네트워크로 연결된 단말이나 같은 단말 내의 애플리케이션을 지정할 수 있음
* 네트워크로 연결된 단말을 지정하여 통신하려면?
  * **어느 단말(IP)** 의 **어느 애플리케이션(포트 번호)** 과 통신할 것인지 미리 정해야 함
* 실제로 통신할 때는 물리 케이블을 이더넷 포트에 꽂아 단말끼리 접속함
* 소켓은 문자 그대로 애플리케이션에 **가상으로 존재하는 이더넷 포트임**
* 소켓으로 통신할 때는
  * 소켓이 지정한 포트에 `전용 이더넷 포트`를 만들고,
  * 통신 상대의 `가상 이더넷 포트`와 `가상 케이블`로 연결된 것 같은 상태로 통신함
  * 소켓을 이용하면 같은 단말에 있는 다른 애플리케이션과 통신할 수도 있음

### TCP 소켓 프로그래밍
* TCP로 접속하는 단말은 `접속을 기다리는 서버`와 `접속을 요청하는 클라이언트`로 나뉨

##### TCP 서버의 대기
* 소켓을 사용하려면 소켓을 생성해서 사용할 **포트 번호**를 할당하고, 클라이언트가 접속할 수 있도록 **대기**해야 함
* 소켓을 조작하는 Socket 클래스(소켓으로 TCP 통신을 하는 절차)
```C#
<TCP 서버에 접속: SocketSampleTCP.StartListener>
void StartListener(int port)
{
  //소켓을 생성한다.
  m_listener = new Socket(AddressFamily.InterNetwork,
    SocketType.Stream, ProtocolType.Tcp);                                  ------ (1)

  //사용할 포트 번호를 할당한다.
  m_listener.Bind(new IPEndPoint(IPAddress.Any, port));                    ------ (2)

  //대기를 시작한다.
  m_listener.Listen(1);                                                    ------ (3)

  m_state = State.AcceptClient;
}
```
* 먼저 기다릴 소켓을 생성 (1)
  * 변수 m_listener에 Socket 클래스의 인스턴스를 생성
  * m_listener는 대기 전용 소켓으로 `리스닝 소켓(listening socket)` 이라고 함
  * 서버는 클라이언트가 언제라도 접속을 요청할 수 있도록 리스닝 소켓을 미리 만들어 대기 상태로 해둠
  * 소켓의 종류는 `SocketType.Stream` , 프로토콜은 `ProtocolType.TCP` 로 지정하여 TCP 통신용 리스닝 소켓의 인스턴스를 생성함
* 생성한 리스닝 소켓 m_listener에 인수 port로 지정된 **포트 번호**를 할당 (2)
  * Bind 함수를 사용해서 연관 지을 `엔드 포인트(end point)` 를 지정함
  * 엔드 포인트는 보통 네트워크 단말을 가리키지만, 여기서는 **네트워크 주소**를 지정함
* Listen 함수를 호출하여 리스닝 소켓을 대기 상태로 만듦 (3)
* 이와 같은 과정을 마치면 리스닝 소켓은 클라이언트에게서 오는 접속 요청을 기다리는 상태가 됨
* 클라이언트의 접속 요청을 받아들이기 위한 스크립트
```C#
<클라이언트의 접속 요청을 접수: SocketSampleTCP.AcceptClient>
void AcceptClient()
{
  if(m_listener != null && m_listener.Poll(0, SelectMode.SelectRead))      ----- (4)
  {
    //클라이언트가 접속했다.
    m_Socket = m_listener.Accept();                                        ----- (5)
    m_isConnected = true;
  }
}
```
* 서버는 `Accept 함수`를 호출하여 클라이언트의 접속 요청을 받음
  * Accept 함수는 클라이언트가 접속을 요청할 때까지 **블로킹**함
  * `블로킹(blocking)` : 호출한 함수를 처리할 때까지 처리의 제어가 돌아오지 않는 것을 말함
  * 즉, Accept 함수를 호출하면 클라이언트와 접속할 때까지 이 함수 안에서 처리를 계속하고, 그동안 애플리케이션은 정지함
  * But, 온라인 게임은 블로킹되면 게임을 진행할 수 없기에 해결해야 함
* 이러한 문제를 해결하기 위해 `Poll 함수`로 클라이언트가 보내는 **데이터를 감시**해서 **데이터를 수신했을 때만 Accept 함수를 호출**하도록 함 (4)
* 클라이언트가 접속을 요청하면 Accept 함수는 요청한 클라이언트와 통신하기 위해 Socket 클래스의 인스턴스를 반환함 (5)
* 이후로는 새로 생성한 소켓 인스턴스를 사용해서 클라이언트와 통신함
  
##### TCP 클라이언트 접속
* 대기 중인 서버에 접속하는 단계
* 서버와 마찬가지로 클라이언트에서도 통신을 담당할 **소켓을 생성**
* 통신 상대가 될 단말의 `IP 주소`와 `포트 번호`를 지정해서 접속을 시도함
* 통신할 서버의 `리스닝 소켓`이 **대기 상태**라면 접속할 수 있음
* 소켓을 이용해서 서버에 접속하는 스크립트
```C#
<TCP 서버로 접속 : SocketSampleTCP.ClientProcess(접속 부분만 발췌)>
void ClientProcess()
{
  //서버에 접속
  m_socket = new Socket(AddressFamily.InterNetwork,
    SocketType.Stream, ProtocolType.Tcp);                                ----- (1)
  m_socket.NoDelay = true;                                               ----- (2)
  m_socket.SendBufferSize = 0; //즉시 보내기 위해 0으로 설정
  m_socket.Connect(m_address, m_port);                                   ----- (3)
}
```
* 소켓을 생성하여 서버에 접속
  * Socket 클래스 변수 m_socket에 Socket 클래스의 인스턴스를 생성 (1)
* 생성한 소켓은 **작은 패킷을 버퍼링하지 않도록** Socket.NoDelay 속성을 true로 하고, Socket.SendBufferSize 속성을 0으로 설정함 (2)
* m_socket에 접속할 서버의 `IP 주소`와 `포트 번호`를 지정해서 접속을 요청함 (3)
  * 접속을 요청할 때는 Socket 클래스의 `Connect 함수`를 사용함
  * Connect 함수는 블로킹 함수라서 접속을 완료할 때까지 다른 처리를 실행할 수 없음
  * Socket.Blocking 속성을 false로 지정하면 Connect 함수를 블로킹하지 않지만, 접속이 완료될 때까지 기다리지 않으므로 통신 상대의 접속이 완려되었는지 애플리케이션에서 감시해야 함

##### 데이터 송수신
* 서버와 클라이언트가 연결된 뒤,
  * 서버는 Accept 함수로 가져온 Socket 클래스의 인스턴스를 사용하고,
  * 클라이언트는 Connect 함수로 접속한 인스턴스를 사용해서 통신함
  * 이후 소켓의 `Send 함수`와 `Receive 함수`로 데이터를 송수신함
    * **Send 함수**로 내보낸 데이터는 수신 단말의 버퍼에 저장됨
    * 버퍼에 저장된 데이터는 **Receive 함수**를 호출하여 가져올 수 있음
* 데이터 송수신 프로그램의 핵심 코드 2가지
```C#
<TCP 송신 : SocketSampleTCP.ClientProcess(송신 부분만 발췌)>
void ClientProcess()
{
  //메시지 송신
  byte[] buffer = 
    System.Text.Encoding.UTF8.GetBytes("Hello, this is client.");
  m_scoket.Send(buffer, buffer.Length, SocketFlags.None);
}
```
```C#
<TCP 수신 : SocketSampleTCP.ServerCommunication>
void ServerCommunication()
{
  byte[] buffer = new byte[1400];
  int recvSize = m_socket.Receive(buffer, buffer.Length, SocketFlags.None);
  if(recvSize > 0)
  {
    string message = System.Text.Encoding.UTF8.GetString(buffer);
    Debug.Log(message);
    m_state = State.StopListener;
  }
}
```
* 송수신 사이에 오가는 건 바이트, 받을 땐 원하는 타입으로 바꿀 수 있음
* 애플리케이션이 Receive 함수를 호출할 때까지 데이터는 시스템의 버퍼에 계속 저장됨
  * So, Receive 함수를 호출하지 않은 채 내버려 두면 수신 버퍼의 공간이 없어져 더는 수신할 수가 없음
  * 애플리케이션에서 적절히 Receive 함수를 호출하여 수신 버퍼를 비워줘야 함

##### 통신 상대와 접속 종료
* 통신을 종료할 때는 `Shutdown 함수`로 패킷 송수신을 차단한 다음, `Close 함수`로 접속을 끊음
```C#
<TCP 접속 종료 : SocketSampleTCP.ClientProcess(접속 종료 부분만 발췌)>
void ClientPorcess()
{
  //접속 종료
  m_socket.Shutdown(SocketShutdown.Both);
  m_socket.Close();

  Debug.Log("End client communication.");
}
```
* 서로 송신한 데이터를 모두 받은 뒤 통신을 종료시킬 떄는 `Shutdown 함수`로 송신만 종료시키고,
* 수신이 종료된 뒤에 `Close 함수`를 호출함
* 서버의 대기 상태를 종료할 때는 Close 함수를 호출하여 리스닝 소켓을 닫음
```C#
<TCP 대기 상태 종료 : SocketSampleTCP.StopListener>
void StopListener()
{
  //대기 상태를 종료한다.
  if(m_listener != null)
  {
    m_listener.Close();
    m_listener = null;
  }

  m_state = State.EndCommunication; //내 현제 서버 상태 체크 위함

  Debug.Log("End server communication.");
}
```

### UDP 소켓 프로그래밍
* UDP는 접속하지 않고도 통신할 수 있음
* TCP와 달리 `서버와 클라이언트의 구별`도 없고, 이 때문에 `서버가 대기할 필요`도 없음
* 소켓을 생성해서 사용할 `포트 번호를 저장`하는 것만으로 통신할 수 있는 상태가 됨
* UDP 포트 번호를 할당해서 통신할 수 있는 상태가 되기까지의 스크립트
```C#
<UDP 송수신 : SocketSampleUDP.SendMessage>
void SendMessage()
{
  //서버에 접속
  m_socket = new Socket(AddressFamily.InterNetwork,
    SocketType.Dgram, ProtocolType.Udp);

  //메시지 송신
  byte[] buffer = 
    System.Text.Encoding.UTF8.GetBytes("Hello, this is client.");
  IPEndPoint endpoint = new IPEndPoint(IPAddress.Parse(m_address), m_port);
  m_socket.SendTo(buffer, buffet.Length, SocketFlags.None, endpoint); //endpoint-주소입력
}
```
* UDP로 송수신할 때는 `SendTo 함수` , `ReceiveFrom 함수`를 사용함
  * 접속 절차가 없으므로 보낼 곳의 `IP 주소`와 `포트 번호`를 지정해서 메시지를 보내면 됨
  * `SendTo 함수`로 송신할 때마다 `IP 주소`와 `포트 번호`를 지정하므로 소켓 하나로 여러 곳에 데이터를 보낼 수 있음
  * 수신할 때는 어느 단말에서 보낸 데이터인지 구별하기 위해 `ReceiveFrom 함수`를 호출할 때마다 `IP 주소`와 `포트 번호`를 가져와서 보낸 곳을 식별함
* 이후, `Close 함수`를 호출하여 통신을 종료함, 호출한 다음 생성한 소켓을 닫으면 통신이 완료됨
* UDP는 `비연결형(connectionless)` 으로 송수신할 수 있지만, `Connect 함수`를 사용하여 커넥션을 확립할 수도 있음
  * 이때는 접속한 소켓하고만 송수신할 수 있지만, `Send 함수`와 `Receive 함수`를 사용할 수 있으며,
  * 어느 단말에서 온 데이터인지 애플리케이션에서 식별할 필요가 없음

</div>
</details>

___

<details>
<summary>3.2 네트워크 바이트 오더</summary>
<div markdown="1">       

### 네트워크 바이트 오더(byte order)란?
* 2바이트 이상의 데이터를 메모리에 배치하는 방식
  * **빅 엔디언(big endian)** : 상위 바이트부터 차례로 배치하는 방식
  * **리틀 엔디언(little endian)** : 하위 바이트부터 차례로 배치하는 방식
    
### 네트워크 바이트 오더를 고려한 데이터 송수신
* 엔디언은 프로세서에 따라 달라짐
  * 같은 엔디언을 사용하는 프로세서끼리 데이터를 송수신할 때는 문제가 없으나.
  * 송신 측과 수신 측이 다른 프로세서를 사용할 때는 송신한 데이터와 수신한 데이터의 값이 달라짐
  * So, 다른 프로세서 간 데이터를 송수신할 때는 바이트 오더를 일치시켜야 보내는 쪽과 받는 쪽 각각의 엔디언으로 데이터를 바르게 다룰 수 있음
* 송신할 데이더가 빅 엔디언 배열로 되어 있다면, `네트워크 바이트 오더`로 변환해서 송신함
* 수신한 데이터는 `네트워크 바이트 오더`로 되어 있으므로 처리할 프로세서에 맞는 바이트 오더로 변환
* 처리할 프로세서의 바이트 오더를 `호스트 바이트 오더`라고 함
* C#에는 IPAddress 클래스에 short형, int형, long형의 바이트 오더를 변환하는 편리한 메서드가 존재
  * **HostToNetworkOrder 함수** : 단말에서 데이터를 송신할 때 네트워크 바이트 오더로 변환
  * **NetworkToHostOrder 함수** : 수신한 데이터를 수신한 단말의 엔디언으로 변환
  * 호스트 바이트 오더 → 네트워크 바이트 오더
    * short형 : int16 HostToNetworkOrder(Int16 val);
    * int형 : int32 HostToNetworkOrder(Int32 val);
    * long형 : int64 HostToNetworkOrder(Int 64 val);
  * 네트워크 바이트 오더 → 호스트 바이트 오더
    * short형 : int16 NetworkToHostOrder(Int16 val);
    * int형 : int32 NetworkToHostOrder(Int32 val);
    * long형 : int64 NetworkToHostOrder(Int64 val);
</div>
</details>

___

<details>
<summary>3.3 간단한 통신 라이브러리를 만들어보자</summary>
<div markdown="1">       

### 왜 라이브러리를 만드는가?
* 통신의 기본은 접속, 송신, 수신, 접속 종료임
  * 이를 실행하려면 Socket 클래스의 인스턴스를 참조해야 하므로 송수신이 이루어지는 곳마다 Socket 클래스의 인스턴스를 참조하는 코드를 작성해야 함
  * But, 게임 프로그램에는 다른 단말과 통신하는 기능만 있으면 될 뿐, Socket 클래스의 인스턴스까지 직접 다룰 필요는 없음
  * 매번 같은 코드를 작성할 바에는 `통신 라이브러리`로 만들어 두고 재활용하는 편이 좋음
  * 라이브러리를 만들어두면 **번거로운 작업이 줄어들고, 버그가 들어갈 여지도 줄어듦**
* So, 이번 절에서는 게임 프로그램에서 Socket 클래스의 인스턴스를 숨기고 통신의 기본적인 처리를 제공하는 라이브러리를 만들 예정
  * Socket 클래스의 래퍼를 작성하는 것부터 시작
    * 래퍼란? 래핑, 즉 클래스 안에 싸서 묶는다는 뜻
      
### API(Application Programming Interface)를 검토하자
* 통신 라이브러리가 처리하는 것
* $\color{#f00}{\textsf{대기 시작, 대기 종료}}$
  * 대기하는 `Bind 함수`, `Listen 함수(TCP만)` 에는 각각 **엔드 포인트**, **최대 접속수**가 필요함
  * `엔드 포인트` : **IP 주소**와 **포트 번호**가 필요함
  * 이 라이브러리에서는 Bind 함수에서 할당할 IP 주소로 `IPAddress.Any`를 사용하므로 게임 애플리케이션에서는 `포트 번호`와 접속할 수 있는 `클라이언트 수`를 지정함
  * 시작할 때 할당한 소켓을 **Close**하면 대기를 종료함
  * 대기 시작, 대기 종료 인터페이스
```C#
//대기 시작
public bool StartServer(int port, int connectionNum);
//대기 종료
public bool StopServer();
```

* $\color{#f00}{\textsf{접속, 접속 종료}}$
  * Socket 클래스에서 `Connect 함수`로 접속
  * `Connect 함수` : 리모트 단말(통신 상대의 단말)의 **엔드 포인트(IP 주소, 포트 번호)** 가 필요
    * 접속 시 IP 주소와 포트 번호를 인수로 가짐
  * `Shutdown 함수(TCP만)` , `Close 함수`로 접속을 종료
  * 접속, 접속 종료 인터페이스
```C#
//접속
public bool Connect(string address, int port);
//접속 종료
public bool Disconnect();
```

* $\color{#f00}{\textsf{송신, 수신}}$
  * TCP 통신으로 송수신할 때는 `Send 함수`와 `Receive 함수`를 사용
  * UDP 통신일 경우에는 `SendTo 함수`와 `ReceiveFrom 함수`를 사용
  * 송신, 수신 인터페이스
```C#
//데이터 송신
public int Send(byte[] data, int size);
//데이터 수신
public int Receive(ref byte[] buffer, int size);
```
* 위와 같은 처리를 하는 함수인 Socket 클래스의 인스턴스를 외부에서 참조할 수 없는 형태로 작성!

### 이벤트 처리
* 게임 프로그램에서 Socket 클래스를 직접 다룬다면 상대의 접속이나 통신 중에 발생한 오류 이벤트를 게임 프로그램에서 검출해서 대처함
* But, Socket 클래스를 숨겨 **라이브러리**로 만들면 게임 프로그램은 Socket 클래스를 참조할 수 없으므로 접속 및 오류를 검출할 수 없음
* So, 라이브러리가 이벤트를 검출해서 게임 프로그램에 알려줘야 함
 * `델리게이트`를 사용하여 접속, 접속 종료, 오류 발생 이벤트를 게임 프로그램에 알려줌
* C#의 `델리게이트(delegate)` 는 함수의 시그니처를 정의하는 형태
 * 함숫값의 형과 인수의 파라미터가 일치하는 함수를 등록하고,
 * 등록한 함수에 파라미터를 전달하여 호출
 * C++의 함수 포인터나 콜백 함수의 기능과 같음
* 게임 프로그램은 **오류 발생 시 호출할 함수**를 `통신 라이브러리`에 등록
* 접속 및 오류 발생 시 통신 라이브러리가 등록된 함수에 알리고, 게임 프로그램은 알림 내용에 따라 대응
* Socket 클래스를 참조해서 검출하는 이벤트(발생하는 이벤트)
 * **접속, 접속 종료, 송신 오류, 수신 오류**
* 이벤트 종류 정의 스크립트
```C#
//이벤트 정의
public enum NetEventType
{
  Connect = 0,  //접속 이벤트
  Disconnect,   //접속 종료 이벤트
  SendError,    //송신 오류
  ReceiveError, //수신 오류
}

//이벤트 결과
public enum NetEventResult
{
  Failure = -1,  //실패
  Success = 0,   //성공
}

//알림 이벤트의 상태
public class NetEventState
{
  public NetEventType type;      //이벤트 타입
  public NetEventResult result;  //이벤트 결과
}
```
* 델리게이트를 정의하여 이 정보를 게임 애플리케이션에 알림
```C#
public delegate void 	EventHandler(NetEventState state);

private EventHandler	m_handler;
```
* 게임 애플리케이션에 델리게이트를 등록하여 이벤트가 발생할 때 호출하는 구조
 * `RegisterEventHandler 함수`와 `UnregisterEventHandler 함수`로 게임 애플리케이션에서 호출할 이벤트 함수를 델리게이트의 **변수 m_handler**에 등록 및 삭제할 수 있음
* 이벤트가 발생했을 때 이벤트 함수를 호출하는 방법(이벤트 알림 호출)
```C#
void AcceptClient()
{
  if(m_listener != null && m_listener.Poll(0, SelectMode.SelectRead))
  {
    //클라이언트가 접속했다.
    m_socket = m_listener.Accept();
    m_isConnected = true;
    //이벤트를 알린다.
    if(m_handler != null)
    {
      NetEventState state = new NetEventState();
      state.type = NetEventType.Connect;
      state.result = NetEventResult.Success;
        m_handler(state);  //EventCallback 함수 연결
    }
  }
}
```
* Accept 함수로부터 처리가 되돌아오면 클라이언트와 통신하는 새로운 Socket 클래스의 인스턴스를 받을 수 있음
* Accept 함수에서 인스턴스를 가져왔다면 클라이언트가 접속했다는 뜻 → 접속 이벤트를 발생시킴
* 이때 접속 이벤트를 나타내는 `NetEventType.Connect`를 델리게이트에 건네줌으로써 애플리케이션에 접속 이벤트를 알릴 수 있음

### 스레드를 사용해보자
<details>
<summary>스레드란?</summary>
<div markdown="1">       

* 컴퓨터 프로그램 수행 시 프로세스 내부에 존재하는 수행 경로, 즉 일련의 실행 코드
* 프로세스는 단순한 껍데기일 뿐, 실제 작업은 스레드가 담당함
* 프로세스 생성 시 하나의 주 스레드가 생성되어 대부분의 작업을 처리하고, 주 스레드가 종료되면 프로세스도 종료됨
* `멀티태스킹` : 하나의 운영 체계에서 여러 개의 프로세스가 동시에 실행되는 환경
* `멀티스레딩` : 하나의 프로세스 내에서 다수의 스레드가 동시에 수행되는 것
* 스레드 사용이 필요한 이유?
 * 게임 애플리케이션의 일부로 통신을 처리하면 게임 자체를 처리하는 데 부하가 걸림
 * So, 통신을 하다가 정작 중요한 게임이 버벅거릴 가능성이 있기 때문
 * 또한, 통신 쪽도 부하가 높아지면 수신 버퍼가 넘쳐 패킷이 유실되기 때문임
* 통신과 게임을 별도의 스레드(thread)로 실행하면 게임 쪽 스레드(메인 스레드)에 영향을 주지 않고 통신할 수 있음
 * 요즘 CPU는 멀티코어(CPU 2개)로 되어 있어 메인 스레드와 통신을 서로 다른 코어에서 실행한다면 게임에 대한 부하를 더욱 가볍게 할 수 있음
 * 통신 측도 수신 버퍼의 데이터를 게임의 버퍼로 수시로 옮길 수 있으므로 수신 버퍼가 넘치지 않고 데이터를 계속 수신할 수 있음
* `메인 스레드`와 `통신 스레드`는 데이터를 주고받는 `버퍼`를 공유할 뿐
 * 이 버퍼에 접근할 때만 주의하면 메인 스레드는 통신 스레드에서 이루어지는 데이터 송수신 타이밍에 신경 쓰지 않고 게임을 처리할 수 있음
</div>
</details>

<details>
<summary>패킷 큐(Packet Queue)</summary>
<div markdown="1">       

</div>
</details>

<details>
<summary>통신 스레드</summary>
<div markdown="1">       

</div>
</details>
### 실제 라이브러리 작성
</div>
</details>
