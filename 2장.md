# 통신 프로그램의 기초 지식

<details>
<summary>2.1 피해갈 수 없는 통신의 구조</summary>
<div markdown="1">       

#### 데이터는 어떻게 전달되는가
* **패킷** : 데이터를 전달하는 구조(묶음)
* 컴퓨터 등의 단말 안에 있는 데이터는 `패킷` 이라는 그릇에 담겨서 운반됨
* 단말은 데이터를 패킷에 넣어 **통신할 상대에게 보냄**
* 데이터 송신은 패킷에 `IP 주소` 라는 수신인 정보를 넣어서 보냄
  * **IP 주소** : 문자 그대로 단말에 할당된 주소를 뜻함
* 데이터를 보낼 때는 `포트 번호`를 패킷에 실어 보냄
  * IP 주소로 보낸 짐이 도착하면 포트 번호로 이 주소에 살고 있는 누구 앞으로 온 건지 알 수 있음
  * 즉, 통신 상대의 단말에서 받은 데이터를 어느 애플리케이션에서 사용할지 판단할 수 있음

#### 데이터가 사라진다?
* 패킷에서도 도중에 데이터가 사라지거나(**패킷 유실**) 파괴되는 경우가 있음
  * 일부 기기가 고장 나서 송신 데이터를 더는 운반할 수 없을 때
  * 성능이 낮은 일부 기기에 처리할 수 있는 양을 넘어서는 데이터가 전달될 때
* 이러한 패킷 유실 문제를 대처하기 위한 방법은 아래에서 다룰 예정
* 허브/스위치/스위치/공유기의 차이
  * **허브**
    * 컴퓨터와 컴퓨터를 연결해주는 장치
    * 각각의 컴퓨터들의 주소(MAC 주소)를 기억하지 않기 때문에 네트워크 규모가 커지면 통신 효율이 떨어짐
  * **스위치**
    * 컴퓨터와 컴퓨터를 연결해주는 장치
    * MAC 주소를 기억해 허브보다 효율적인 통신을 가능케 함
  * **라우터**
    * 네트워크가 인터넷에 접속할 수 있도록 해주는 장치
    * 통신 신호들의 경로를 지정해주는 장치
  * **공유기**
    * 네트워크의 컴퓨터들이 인터넷에 접속할 수 있도록, IP 주소를 할당해 주는 장치
    * 하나의 회선에서 여러 대의 컴퓨터가 인터넷에 접속할 수 있게 해줌
</div>
</details>

___

<details>
<summary>2.2 프로토콜 이해하기</summary>
<div markdown="1">       

#### 안심할 수 있는 TCP
* TCP의 접속 처리를 이용하면 **확인 응답(ACK, Acknowledgement)** 이라는 답장이 되돌아옴
* 응답 안에 있는 수신 버퍼의 크기보다 보내고자 하는 데이터가 작으면 전송을 시작함
* 데이터를 보낼 수 있는 상태인 경우 TCP는 데이터 전송을 시작함
* 데이터를 수신하면 수신했음을 알리는 확인 응답을 돌려보냄
* 보낸 곳에서 확인 응답 메시지를 받으면 데이터 전송은 끝남
* 이처럼 TCP는 여러 가지 통지와 응답을 내부에서 주고받으면서 데이터를 송수신함
  
#### TCP의 장점과 단점
* 데이터의 **전송과 순서를 보증**하므로 전송 순서가 중요한 데이터를 주고받을 때 사용하며, HTTP와 FTP에서 사용되는 프로토콜임
* 전송할 데이터가 클 경우
  * 데이터를 **`세그먼트(segment)`**라는 데이터로 작게 나누고, TCP가 다룰 수 있는 **`헤더(header)`**를 세그먼트에 붙임
  * 즉, 크기가 큰 데이터는 통신 상대에게 통째로 전달하는 게 아니라 **통신에서 다룰 수 있는 크기로 나눔**
  * 애플리케이션에서 보낸 **`스트림 데이터(stream data)`**를 버퍼에 저장하고, 데이터를 세그먼트로 나누어 송수신함
  * 수신한 쪽은 세그먼트를 다시 결합해서 애플리케이션에 전달함
* 전송할 데이터가 작을 경우
  * 각각의 작은 데이터를 TCP 버퍼에 한데 모아 시스템이 최적인 타이밍에 송신함
  * So, 애플리케이션이 송신을 지시해도 **TCP 버퍼가 꽉 차거나 규정 시간이 지나기 전**에는 실제로 송신되지 않음
  * 결국, **애플리케이션이 지시한 타이밍보다 지연되어 송신된다는 단점**이 있음
* 수신 데이터는 송신된 때와 상태가 같지 않음
  * 데이터를 전송하기 쉽게 결합해서 보내고 그대로 수신함
  * So, 수신하는 쪽 애플리케이션에서는 결합한 데이터를 다시 나누어야 함
* 정리
  * 순서에 맞춰 꼼꼼하게 수송신이 진행되기 때문에 보다 정확하다는 장점이 있음
  * 반면, 그만큼 시간이 오래 걸린다는 단점을 지님

#### 속도가 빠른 UDP
* UDP는 쓸데없는 처리를 하지 않음
* 큰 데이터를 작게 나누거나 작은 데이터를 모으지도 않음
* 전달과 순서를 보증하지 않는 대신 빠른 속도를 자랑함

#### UDP의 장점과 단점
* 장점
  * 복잡한 처리를 하지 않는 대신에 **데이터를 빠르게 전달**할 수 있음
* 단점
  * TCP처럼 **전달이나 순서를 보증하는 등의 편리한 기능이 없음**
    * So, 전달을 보증하지 않으므로
      * 패킷이 유실돼도 재전송하지 않고 그대로 데이터가 없어지기 때문에 대량으로 데이터를 전송하려면 애플리케이션에서 데이터 송수신을 관리해야 함
    * 순서도 보증하지 않으므로 전달한 순서가 뒤바뀐 경우에는 애플리케이션에서 순서를 바로잡아야 함

#### 온라인 게임에서 사용하는 프로토콜
|  | TCP | UDP |
| :---: | :---: | :---: |
| 장점 | 전달을 보증한다.| 처리가 단순하고 전송 속도가 빠르다. |
|      | 순서를 보증한다.|                                  |
|      | 혼잡을 제어한다.|                                  |
| 단점 | 처리가 복잡하므로 전송 속도가 느리다. | 전달을 보증하지 않는다.|
|      |                                    |순서를 보증하지 않는다. |

* 온라인 게임에서는 오히려 UDP를 많이 사용함. why?
  * TCP로 데이터를 주고받으면 순서를 보증해주고 패킷이 유실되면 재전송함
  * 재전송하니 믿음직하지만 이런 재전송 구조는 게임에 적합하지 않음
  * TCP는 최초의 세그먼트를 송신한 뒤 미리 정해진 **`재전송 타임아웃(RTO)`** 시간까지 통신 상대한테 확인 응답이 돌아오지 않으면 재전송함
  * TCP 사양에서는 전송이 반복되면 재전송 타임아웃이 두 배로 늘어남
    * 즉, 재전송 시 타임아웃은 최초 타임아웃보다 시간이 배로 걸린다는 뜻!
    * 턴 게임이면 몰라도 실시간 게임에서는 사용하기 힘들다는 점
* UDP를 채용하고 거기에 TCP와 같은 편리한 기능을 필요한 만큼 구현하면 TCP보다 빨리 보낼 수 있음
  * 재전송 구조는 만들기 어렵지만, 한 번만 작성하면 계속 사용할 수 있음
* **RUDP(Reliable UDP) 프로토콜**
  * 패킷 유실 시 재전송하거나 수신 패킷의 확인 응답을 받는 기능을 갖추고 있음
  * TCP보다 빠르고 편리한 재전송 구조로 전달을 보증하는 UDP를 사용할 수 있음
  * 단, TCP와 UDP 처럼 표준으로 제공되는 프로토콜이 아님
  * SDK로 별도 제공되는 것을 구하거나 프로토콜 사양에 맞게 직접 구현해야 사용 가능함
</div>
</details>

___

<details>
<summary>2.3 알아두면 좋은 기초 지식</summary>
<div markdown="1">       

#### 지연은 반드시 발생한다
* 패킷을 통신 상대에게 보내도 곧바로 전달되지 않음
  * 통신하는 단말 간에 통신 기기가 여러 대 있고, 통신 기기 각각이 패킷을 처리하는 시간이 필요하기 때문에
  * 처리 시간이 누적되면서 전달 시간은 조금씩 지연됨
* So, **송신된 시각**과 **전달된 시각** 사이에 시차가 발생함.
  * 이 시차를 **`지연 시간(레이턴시)`** 라고 함
  * **`편도 레이턴시`** : 데이터를 송신하고 상대에게 전달되기까지의 시간
  * **`왕복 레이턴시`** : 데이터를 송신한 뒤 상대의 응답을 받을 때까지의 시간
* **RTT(Round Trip Time)**
  * 단말 두 대에서 데이터를 송신해달라고 요청했을 때, 상대의 응답을 받을 때까지 어느 정도 시간이 걸렸는지 나타내는 왕복 레이턴시임
* 실시간 온라인 게임에서는 상대의 입력을 즉시 반영하지 않으면 함께 플레이하는 플레이어의 반응이 느려짐
  * But, 통신을 통해 상대의 입력 정보를 반영하려면 적어도 편도 레이턴시만큼은 반드시 느려짐
  * 온라인 게임을 만들 때에는 플레이어가 이런 레이턴시를 느끼지 못하도록 해야 함

#### 통신량을 생각해보자
* 실시간 액션 게임에서는 높은 빈도로 데이터를 전송해야 통신 상대에게 즉시 정보를 반영할 수 있음
  * But, 데이터를 대량으로 자주 보내면 결국 네트워크 이용률이 높아지게 됨
  * 네트워크 이용률이 높아지면 **지연이 커지거나 패킷이 유실되어 다시 전송**해야 함
* 데이터 송신량-통신 대역의 관계(수조 안에 들어오는 물의 양-나가는 물의 양의 관계와 유사
* 물=송신할 패킷/수조=라우터,허브/수조의 용량=처리 능력/물 빠지는 구멍=회선의 굵기(통신 대역)
  * 들어오는 물의 양이 적고 나가는 구멍이 크면 수조에 물이 차지 않고 원활하게 흘러감
    * 들어오는 패킷의 양이 적고 통신 대역이 크면 데이터 송신이 원활하게 흘러감
  * 들어오는 물의 양이 나가는 물의 양보다 많으면 물은 수조 밖으로 넘침
    * 들어오는 패킷의 양이 나가는 패킷보다 많으면 패킷이 유실되어 상대에게 전달되지 않음
  * 수조에 물이 찬 상태 = 라우터 등의 버퍼에 패킷이 채워진 상태, 송신될 순서를 기다리는 것
* 통신 상대의 데이터 통신 속도는 “**통신 대역**이 넓다(혹은 좁다).”고 표현함
  * 통신 대역은 1초에 몇 비트 전송되는지 나타내는 `bps(bit per second)`로 측정할 수 있음
  * 통신 대역이 넓으면 흐르는 데이터양도 많고, 빠르게 송수신할 수 있음
  * 통신 대역이 좁으면 흐르는 데이터양이 적고, 대용량 데이터를 보내면 원활하게 처리할 수 없어 지연과 소실이 발생함
* So, 게임에서 사용하는 데이터 외에 통신 레이어에서 추가되는 만큼 통신량이 증가하기 때문에 게임에서 사용하는 데이터 통신은 **가능한 작은 데이터로, 적은 횟수로 송신**하는 게 좋음
* 통신할 데이터의 사양이 정해지면 필요한 통신량을 계산해서 어느 정도 대역까지 게임을 플레이할 수 있는지 확인하고, 게임을 플레이할 수 있음을 보증하는 통신 대역을 설정해야 함
</div>
</details>
